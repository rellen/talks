
** Gleam

#+BEGIN_EXPORT latex
  \begin{center}
  \includegraphics[width=.5\textwidth]{./img/lucy.png}
  \end{center}
#+END_EXPORT

** Gleam

#+BEGIN_SRC gleam
// https://gleam.run
import gleam/io

pub fn main() {
  io.println("hello, friend!")
}
#+END_SRC

** Gleam

- created by Louis Pilfold (https://github.com/lpil)
- functional: immutable data and HoF, but impure
- statically-typed: Hindley-Milner type system
- strongly-typed
- strict semantics

** Gleam

#+BEGIN_SRC gleam
import gleam/io
import gleam/list

fn sum(xs: List(Int)) -> Int {
  list.fold(xs, 0, fn(acc, x) { acc + x })
}

pub fn main() {
  io.debug(sum([1, 2, 3])) // prints "6"
}
#+END_SRC


** Gleam

- compiles to BEAM or JavaScript
- FFI to JS and Erlang/Elixir - both at the same time with fallback
- all tooling provided by ~gleam~
- ~gleam~ is written in Rust


** Type-inference

#+BEGIN_SRC gleam
import gleam/list

fn sum(xs) {
  list.fold(xs, 0, fn(acc, x) { acc + x })
}

pub fn main() {
  sum(["a", "b", "c"])
}








#+END_SRC

** Type-inference

#+BEGIN_SRC gleam
import gleam/list

fn sum(xs) {
  list.fold(xs, 0, fn(acc, x) { acc + x })
}

pub fn main() {
  sum(["a", "b", "c"])
}

// Produces the compile-time error ...
// 8 │   sum(["a", "b", "c"])
//   │       ^^^^^^^^^^^^^^^
// Expected type:
//     List(Int)
// Found type:
//     List(String)
#+END_SRC

** Type aliases...are not a new type

#+BEGIN_SRC gleam
import gleam/io

pub type SpecialString = String

pub fn main() {
  let normal: String = "I'm a string"
  let special: SpecialString = "I'm a special string"

  io.debug(normal == special) // False
}
#+END_SRC

** Opaque types with smart constructors

#+BEGIN_SRC gleam
import gleam/io

pub opaque type OpaqueString {
	OpaqueString(inner: String)
}

pub fn make(str: String) -> OpaqueString {
  OpaqueString(str <> " (totally a string)")
}

pub fn main() {
  let normal: String = "I'm a string"
  let special: OpaqueString = make("I'm not a string")

  io.debug(normal == special) // Compile error
}
#+END_SRC

** Data types

#+BEGIN_SRC gleam
import gleam/io
import gleam/string

pub type Person {
  Person(name: String, age: Int)
}

pub fn main() {
  let ashley = Person("Ashley", 42)
  let message =
    ashley.name <> " is " <> string.inspect(ashley.age) <> " years old"
  io.println(message)
  // "Ashley is 42 years old"
}
#+END_SRC


** Data types

#+BEGIN_SRC gleam
pub type Shape {
  Square(side: Float)
  Rectangle(length: Float, width: Float)
  Circle(radius: Float)
}

pub fn area(shape: Shape) -> Float {
  case shape {
    // note the *. operator
    Square(side: s) -> s *. s
    Rectangle(length: l, width: w) -> l *. w
    Circle(radius: r) -> 3.14 *. r *. r
  }
}
#+END_SRC

** Data types - no pattern matching in function head

#+BEGIN_SRC gleam
pub type Shape {
  Square(side: Float)
  Rectangle(length: Float, width: Float)
  Circle(radius: Float)
}

// something like this adapted from Erlang/Elixir won't compile
pub fn area(Square(side: s)) {
   s *. s
}

pub fn area(Rectangle(length: l, width: w)) {
   l *. w
}
#+END_SRC


** Type variables - parametric polymorphism but not HKT

#+BEGIN_SRC gleam
import gleam/io
import gleam/string

fn my_fold(collection: List(a), accumulator: b, reducer: fn(a, b) -> b) -> b {
  case collection {
    [] -> accumulator
    [x, ..xs] -> { // expression block
      let new_acc = reducer(x, accumulator)
      my_fold(xs, new_acc, reducer)
    }
  }
}

pub fn main() {
  io.debug(my_fold([1, 2, 3], "", fn(a, b) { string.inspect(a) <> b }))
  // "321"
}
#+END_SRC

** ~Nil~ - the unit type

#+BEGIN_SRC gleam
// gleam_stdlib/src/gleam/io.gleam
...
pub fn println(string: String) -> Nil {
  do_println(string)
}

@external(erlang, "gleam_stdlib", "println")
@external(javascript, "../gleam_stdlib.mjs", "console_log")
fn do_println(string string: String) -> Nil
...
#+END_SRC

** ~todo~ - ``top" type

#+BEGIN_SRC gleam
import gleam/io

// prints "one" then errors at two()
pub fn main() {
  one()
  two()
  three()
}

pub fn one() {
  io.println("one")
}

pub fn two() {
  todo as "two() is not implemented yet!"
}

pub fn three() {
  todo as "three() is not implemented yet!"
}
#+END_SRC

** ~use~ - a monad if you squint

#+BEGIN_SRC gleam
import gleam/io
import gleam/result
import gleam/string

pub fn main() {
  let res = {
    use data <- result.try(read_data())
    use record <- result.map(find_record(data))
    format(record)
  }

  case res {
    Ok(formatted) -> io.println(formatted)
    Error(error) -> io.println("ERROR: " <> error)
  }
}

fn read_data() {
  Ok(#("Ashley", 42))
  Error("couldn't read data")
}

fn find_record(record) {
  Ok(record)
  Error("not found")
}

fn format(record) {
  string.inspect(record)
}
#+END_SRC

** ~use~ - a monad if you squint

#+BEGIN_SRC gleam
fn read_data() {
  Ok(#("Ashley", 42))
}

fn find_record(record) {
  Ok(record)
}
#+END_SRC

** ~use~ - a monad if you squint

#+BEGIN_SRC gleam
import gleam/io
import gleam/result
import gleam/string

// prints "#("Ashley", 42)"
pub fn main() {
  let res = {
    use data <- result.try(read_data())
    use record <- result.map(find_record(data))
    format(record)
  }

  case res {
    Ok(formatted) -> io.println(formatted)
    Error(error) -> io.println("ERROR: " <> error)
  }
}
#+END_SRC

** ~use~ - a monad if you squint

#+BEGIN_SRC gleam
fn read_data() {
  Error("couldn't read data")
}

fn find_record(record) {
  Error("not found")
}

fn format(record) {
  string.inspect(record)
}
#+END_SRC

** ~use~ - a monad if you squint

#+BEGIN_SRC gleam
import gleam/io
import gleam/result
import gleam/string

// prints "ERROR: couldn't read data"
pub fn main() {
  let res = {
    use data <- result.try(read_data())
    use record <- result.map(find_record(data))
    format(record)
  }

  case res {
    Ok(formatted) -> io.println(formatted)
    Error(error) -> io.println("ERROR: " <> error)
  }
}
#+END_SRC
