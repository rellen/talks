# Macro Madness: when busting boilerplate backfires

## What are Macros?

```elixir
defmodule DefMacroExample1 do
  defmacro add_one(x) do
    x + 1
  end
end
```

```elixir
require DefMacroExample1
DefMacroExample1.add_one(2)
```

```elixir
defmodule UsingExample do
  defmacro __using__() do
    def add_one(x), do: x + 1
  end
end
```

```elixir
quote do
  1 + 1
end
```

```elixir
quote do
  def add_one(x), do: x + 1
end
```

```elixir
quote do
  def add_one(x), do: x + 1
end
|> Macro.to_string()
```

```elixir
defmodule UsingExample2 do
  defmacro __using__(_opts) do
    quote do
      def add_one(x), do: x + 1
    end
  end
end
```

```elixir
defmodule UsingUsingExample2 do
  use UsingExample2
end

UsingUsingExample2.add_one(5)
```

```elixir
defmodule UsingExample3 do
  defmacro __using__(_opts) do
    quote do
      def add_one(x), do: x + 1
    end
  end
end
```

### Another example

(from https://elixir-lang.org/getting-started/meta/macros.html)

```elixir
defmodule UnlessFun do
  def fun_unless(clause, do: expression) do
    if(!clause, do: expression)
  end
end
```

```elixir
UnlessFun.fun_unless(true, do: IO.puts("this should never be printed"))
```

### Explanation:

In Elixir function arguments are evaluated eagerly (i.e. before the function receiving the arguments us evaluated)

<!-- livebook:{"break_markdown":true} -->

So, let's try using a macro!

```elixir
defmodule UnlessMacro1 do
  defmacro macro_unless(clause, do: expression) do
    if(clause, do: expression)
  end
end
```

```elixir
require UnlessMacro1
UnlessMacro1.macro_unless(true, do: IO.puts("this should never be printed"))
```

OK, this still doesn't work, we are still evaluating the arguments before running the macro.

But we have `quote`

```elixir
defmodule UnlessMacro2 do
  defmacro macro_unless(clause, do: expression) do
    quote do
      if(!clause, do: expression)
    end
  end
end
```

Warnings! Let's see if it works...

```elixir
require UnlessMacro2
UnlessMacro2.macro_unless(true, do: IO.puts("this should never be printed"))
```

Oh noes!

```elixir
quote do
  if(!clause, do: expression)
end
```

We can't grab an outside variable with just `quote`

```elixir
x = 2
Macro.to_string(quote do: 1 + x)
```

`clause` and `expression` are being considered literally as variable names for the `if` call, rather than as the AST of `clause` and `expression` arguments to our `defmacro`.

What we really want is to grab the AST values held in `clause` and `expression`...

### Enter `unquote`

`unquote` accepts

```elixir
quote do
  unquote({:+, [context: Elixir, import: Kernel], [1, 2]})
end
```

```elixir
quote do
  unquote({:+, [context: Elixir, import: Kernel], [1, 2]})
end
|> Macro.to_string()
```

```elixir
x = 1
y = 2
quote do: unquote(x) + unquote(y)
```

```elixir
x = 1
y = 2

quote do
  unquote(x) + unquote(y)
end
|> Macro.to_string()
```

Let's see the difference `unquote` makes when the variable is a quoted expression

```elixir
x = quote do: IO.puts("Hello, world!")

quote do
  x
end
```

```elixir
x = quote do: IO.puts("Hello, world!")

quote do
  unquote(x)
end
```

So let's try `unquote` with arguments that are full expressions!

```elixir
defmodule UnlessMacro3 do
  defmacro macro_unless(clause, do: expression) do
    quote do
      if(!unquote(clause), do: unquote(expression))
    end
  end
end
```

```elixir
require UnlessMacro3
UnlessMacro3.macro_unless(true, do: IO.puts("this should never be printed"))
```

Happy days!

<!-- livebook:{"break_markdown":true} -->

### Explanation:

In Elixir:

* function arguments are evaluated eagerly (i.e. before the function receiving the arguments us evaluated)
* **macro arguments are not evaluated, but received as quoted expressions**

## Busting boilerplate - backfiring

```elixir
defmodule MyBoilerplateMacro1 do
  defmacro __using__(_) do
    actions = [:action1, :action2]

    Enum.each(actions, fn action ->
      quote do
        def do_action(action) do
          IO.inspect(action)
        end
      end
    end)
  end
end
```

We've seen this before!  Let's use `unquote` to fix it.

```elixir
defmodule MyBoilerplateMacro2 do
  defmacro __using__(_) do
    actions = [:action1, :action2]

    Enum.each(actions, fn action ->
      quote do
        def do_action(unquote(action)) do
          IO.inspect(unquote(action))
        end
      end
    end)

    quote do: def(some_other_fun(x, y), do: x + y)
  end
end

defmodule MyModule2 do
  use MyBoilerplateMacro2
end
```

Weird, looks like no `do_action` functions are exported, but `some_other_fun` is

```elixir
MyModule2.do_action(:action1)
```

Yep, they don't exist

```elixir
MyModule2.__info__(:functions)
```

Then we remember that `defmacro` needs to return quoted AST, and like functions, it will return the value last expression. Hence why `some_other_fun` made the cut, but not `do_action`.

We can try putting all the code in one quote.

```elixir
defmodule MyBoilerplateMacro3 do
  defmacro __using__(_) do
    actions = [:action1, :action2]

    quote do
      Enum.each(unquote(actions), fn action ->
        def do_action(unquote(action)) do
          IO.inspect(unquote(action))
        end
      end)

      def some_other_fun(x, y), do: x + y
    end
  end
end

defmodule MyModule3 do
  use MyBoilerplateMacro3
end
```

```elixir
defmodule MyBoilerplateMacro4 do
  defmacro __using__(_) do
    actions = [:action1, :action2]

    quote do
      Enum.each(unquote(actions), fn action ->
        def do_action(action) do
          IO.inspect(action)
        end
      end)

      def some_other_fun(x, y), do: x + y
    end
  end
end

defmodule MyModule4 do
  use MyBoilerplateMacro4
end
```

These warnings are saying that we got two `do_action` functions with the same argument (literally `action`).

Many other permutations could be tried, and this could be a big time sink!

After much hair-pulling...aha, a breakthrough! If `quote` returns a value, can we assign it to a variable and stitch them together?

```elixir
defmodule MyBoilerplateMacro5 do
  defmacro __using__(_) do
    actions = [:action1, :action2]

    action_funs =
      Enum.map(actions, fn action ->
        quote do
          def do_action(unquote(action)) do
            IO.inspect(unquote(action))
          end
        end
      end)

    some_other =
      quote do
        def some_other_fun(x, y), do: x + y
      end

    [action_funs, some_other]
  end
end

defmodule MyBoilerplateMacro5 do
  use MyMacroModule5
end
```

```elixir
MyModule5.do_action(:action1)
MyModule5.do_action(:action2)
```

```elixir
MyModule5.__info__(:functions)
```

```elixir
Macro.to_string(quote do: (unquote_splicing([1, 2])))
```

```elixir
defmodule MyBoilerplateMacro6 do
  defmacro __using__(_) do
    actions = [:action1, :action2]

    action_funs =
      Enum.map(actions, fn action ->
        quote do
          def do_action(unquote(action)) do
            IO.inspect(unquote(action))
          end
        end
      end)

    some_other =
      quote do
        def some_other_fun(x, y), do: x + y
      end

    quote do
      [unquote_splicing(action_funs), unquote(some_other)]
    end
  end
end

defmodule MyModule6 do
  use MyBoilerplateMacro6
end
```

```elixir
MyModule6.do_action(:action1)
MyModule6.do_action(:action2)
```

```elixir
MyModule2.__info__(:functions)
```
