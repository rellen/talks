% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
  ignorenonframetext,
]{beamer}
\usepackage{pgfpages}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbolsempty
% Prevent slide breaks in the middle of a paragraph
\widowpenalties 1 10000
\raggedbottom
\setbeamertemplate{part page}{
  \centering
  \begin{beamercolorbox}[sep=16pt,center]{part title}
    \usebeamerfont{part title}\insertpart\par
  \end{beamercolorbox}
}
\setbeamertemplate{section page}{
  \centering
  \begin{beamercolorbox}[sep=12pt,center]{part title}
    \usebeamerfont{section title}\insertsection\par
  \end{beamercolorbox}
}
\setbeamertemplate{subsection page}{
  \centering
  \begin{beamercolorbox}[sep=8pt,center]{part title}
    \usebeamerfont{subsection title}\insertsubsection\par
  \end{beamercolorbox}
}
\AtBeginPart{
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \frame{\subsectionpage}
}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\newif\ifbibliography
\usepackage{listings}
\newcommand{\passthrough}[1]{#1}
\lstset{defaultdialect=[5.3]Lua}
\lstset{defaultdialect=[x86masm]Assembler}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\setbeamersize{text margin left=0.35cm}
\setbeamersize{text margin right=0.35cm}

\let\oldverbatim\verbatim
\let\oldendverbatim\endverbatim
\renewenvironment{verbatim}{\scriptsize\oldverbatim}{\oldendverbatim}

% \renewenvironment{Shaded}{\begin{snugshade}\footnotesize}{\end{snugshade}}

\setbeamertemplate{itemize item}{\ast}
\setbeamertemplate{itemize subitem}{--}

\setbeamerfont{itemize/enumerate body}{size=\Large}
\setbeamerfont{itemize/enumerate subbody}{size=\Large}
\setbeamerfont{itemize/enumerate subsubbody}{size=\large}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={The Erlang Ecosystem for Functional Programmers (and everyone else, too)},
  pdfauthor={Robert Ellen},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{The Erlang Ecosystem for Functional Programmers (and everyone
else, too)}
\author{Robert Ellen}
\date{2023/05/16}

\begin{document}
\frame{\titlepage}

\begin{frame}{What is the Erlang Ecosystem?}
\protect\hypertarget{what-is-the-erlang-ecosystem}{}
A group of languages, libraries, frameworks, and applications that are
implemented on top of the Erlang virtual machine, the BEAM.

\includegraphics{ErlangLogo.png}
\end{frame}

\hypertarget{brief-history-of-erlang}{%
\section{Brief history of Erlang}\label{brief-history-of-erlang}}

\hypertarget{the-beam}{%
\section{The BEAM}\label{the-beam}}

\hypertarget{otp-libraries}{%
\section{OTP libraries}\label{otp-libraries}}

\begin{frame}{gen\textsubscript{server}}
\protect\hypertarget{genserver}{}
\end{frame}

\begin{frame}{Supervisors}
\protect\hypertarget{supervisors}{}
\end{frame}

\hypertarget{the-erlang-ecosystem}{%
\section{The Erlang ecosystem}\label{the-erlang-ecosystem}}

\hypertarget{elixir}{%
\section{Elixir}\label{elixir}}

\begin{frame}{Brief history of Elixir}
\protect\hypertarget{brief-history-of-elixir}{}
\begin{itemize}
\tightlist
\item
  created by José Valim starting in 2012
\item
  in search of a safer, faster, and more scalable Ruby
\item
  inspired by Erlang, Ruby, and, to a lesser extent, Lisp
\item
  José got the idea to use Erlang from Bruce Tate\textquotesingle s
  \emph{Seven Languages in Seven Weeks}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Features of Elixir}
\protect\hypertarget{features-of-elixir}{}
\begin{itemize}
\tightlist
\item
  Ruby-like syntax while retaining most of Erlang\textquotesingle s
  semantics
\item
  interoperate with Erlang
\item
  highly ergonomic build tool: \passthrough{\lstinline!mix!}
\item
  modern package manager: \passthrough{\lstinline!hex!}
\item
  opinionated formatter
\item
  drops SSA
\end{itemize}
\end{frame}

\begin{frame}{Pipelines (\textbar\textgreater)}
\protect\hypertarget{pipelines}{}
\end{frame}

\begin{frame}{with form}
\protect\hypertarget{with-form}{}
\end{frame}

\hypertarget{success-typing-with-dialyzer}{%
\section{Success Typing with
Dialyzer}\label{success-typing-with-dialyzer}}

\begin{frame}{Dialyzer}
\protect\hypertarget{dialyzer}{}
\begin{itemize}
\tightlist
\item
  DIscrepancy anALYZer for ERlang
\item
  static-analysis tool for Erlang, Elixir, and BEAM files
\item
  Success Typing - optimise for avoiding false-positives
\end{itemize}
\end{frame}

\begin{frame}{What is Success Typing?}
\protect\hypertarget{what-is-success-typing}{}
\begin{itemize}
\tightlist
\item
  technique to check programs for type inconsistencies
\item
  does not require the type annotations, but they help
\item
  only considers a program in error if it is certain there is an
  inconsistency
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Using Dialyzer in Elixir}
\protect\hypertarget{using-dialyzer-in-elixir}{}
\begin{lstlisting}
# mix.exs
{:dialyxir, "~> 1.3", only: [:dev], runtime: false}
\end{lstlisting}

\begin{lstlisting}[language=bash, org-language=sh]
mix dialyzer # pass flags like --missing_return
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example}
\protect\hypertarget{type-example}{}
\begin{lstlisting}
defmodule DialyzerExample.TypeExample do
  def add(a, b), do: a + b

  def concat(str1, str2), do: str1 <> str2

  @spec wat(number(), String.t()) :: number()
  def wat(a, b), do: a + b

  def run_add, do: add(1, :two)
  def run_concat, do: concat(:not_a_string, "suffix")
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example - \passthrough{\lstinline!wat/2!}}
\protect\hypertarget{type-example---wat2}{}
\begin{lstlisting}
lib/type_example.ex:6:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
DialyzerExample.TypeExample.wat/2

Success typing:
@spec wat(number(), number()) :: number()
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example - \passthrough{\lstinline!add/2!}
(\passthrough{\lstinline!concat/2!} similarly)}
\protect\hypertarget{type-example---add2-concat2-similarly}{}
\begin{lstlisting}
lib/type_example.ex:9:no_return
Function run_add/0 has no local return.
________________________________________________________________________________
lib/type_example.ex:9:call
The function call will not succeed.
DialyzerExample.TypeExample.add(1, :two)

will never return since the 2nd arguments differ
from the success typing arguments:

(number(), number())

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example - extra warning flags}
\protect\hypertarget{type-example---extra-warning-flags}{}
\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!mix dialyzer --extra\_return --missing\_return!}
\end{itemize}

\begin{lstlisting}
defmodule DialyzerExample.ExtendedExample do
  @spec extra_return(integer()) :: :even | :odd | :zero
  def extra_return(a) do
    if rem(a, 2) == 0, do: :even, else: :odd
  end

  @spec missing_return(integer()) :: :even | :odd
  def missing_return(a) do
    cond do
      a == 0 -> :zero
      rem(a, 2) == 0 -> :even
      rem(a, 2) != 0 -> :odd
    end
  end
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example -
\passthrough{\lstinline!extra\_return!}}
\protect\hypertarget{type-example---extra_return}{}
\begin{lstlisting}
lib/extended_example_a.ex:2:extra_range
The type specification has too many types for the function.

Function:
DialyzerExample.ExtendedExample.extra_return/1

Extra type:
:zero

Success typing:
:even | :odd

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example -
\passthrough{\lstinline!missing\_return!}}
\protect\hypertarget{type-example---missing_return}{}
\begin{lstlisting}
lib/extended_example_a.ex:7:missing_range
The type specification is missing types returned by function.

Function:
DialyzerExample.ExtendedExample.missing_return/1

Type specification return types:
:even | :odd

Missing from spec:
:zero

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Match example - inexhaustive function clauses}
\protect\hypertarget{match-example---inexhaustive-function-clauses}{}
\begin{lstlisting}
defmodule DialyzerExample.MatchExampleA do
  @type tag :: :foo | :bar
  @type tagged_type :: {tag(), term()}

  @spec handle(tagged_type()) :: term()
  def handle(tagged_data)

  def handle({:foo, data}) do
    IO.inspect(data, label: "got foo")
  end

  # where do we handle :bar??
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Match example - call unmatched function clause}
\protect\hypertarget{match-example---call-unmatched-function-clause}{}
\begin{lstlisting}
defmodule DialyzerExample.MatchExampleB do
  @type tag :: :foo | :bar
  @type tagged_type :: {tag(), term()}

  @spec handle(tagged_type()) :: term()
  def handle(tagged_data)

  def handle({:foo, data}),
    do: IO.inspect(data, label: "got foo")

  # Let's actually call handle/1
  def run do
    handle({:foo, "foo"})
    handle({:bar, "bar"})
  end
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Match example -
\passthrough{\lstinline!mix dialyzer!}}
\protect\hypertarget{match-example---mix-dialyzer}{}
\begin{lstlisting}
lib/match_example_b.ex:12:no_return
Function run/0 has no local return.
________________________________________________________________________________
lib/match_example_b.ex:14:call
The function call will not succeed.

DialyzerExample.MatchExampleB.handle({:bar, <<98, 97, 114>>})

will never return since the 1st arguments differ
from the success typing arguments:

({:foo, _})

________________________________________________________________________________
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Case Example - non-exhaustive case}
\protect\hypertarget{case-example---non-exhaustive-case}{}
\begin{lstlisting}
defmodule DialyzerExample.CaseExample do
  @type tag :: :foo | :bar
  @type tagged_type :: {tag(), term()}

  @spec handle(tagged_type()) :: term()
  def handle(tagged_data)

  def handle({tag, data}) do
    case tag do
      :foo -> IO.inspect(data, label: "got foo")
    end
  end

  def run do
    handle({:baz, "baz"})
  end
end
\end{lstlisting}
\end{frame}

\begin{frame}{Tips for using Dialyzer}
\protect\hypertarget{tips-for-using-dialyzer}{}
\begin{itemize}
\tightlist
\item
  start using at the beginning of a project
\item
  run the mix task to create Persistent Lookup Table files
\item
  cache PLTs for Erlang, Elixir, and deps in CI

  \begin{itemize}
  \tightlist
  \item
    \url{https://github.com/team-alembic/staple-actions/tree/main/actions/mix-dialyzer}
  \end{itemize}
\end{itemize}
\end{frame}

\hypertarget{gradual-typing-with-gradualizer-gradient}{%
\section{Gradual Typing with Gradualizer /
Gradient}\label{gradual-typing-with-gradualizer-gradient}}

\begin{frame}[fragile]{What is Gradual Typing?}
\protect\hypertarget{what-is-gradual-typing}{}
\begin{itemize}
\tightlist
\item
  a form of type system that combines static and dynamic types
\item
  a gradually-typed program annotates parts of its code with types
\item
  some of the program will then have known types, other parts will have
  a \passthrough{\lstinline!unknown!} type
\item
  a gradual type checker ensures parts of values with known types are
  consistent
\end{itemize}
\end{frame}

\begin{frame}{Gradualizer}
\protect\hypertarget{gradualizer}{}
\begin{itemize}
\tightlist
\item
  \url{https://github.com/josefs/Gradualizer}
\item
  gradual type checker for Erlang
\item
  relies on type specs
\item
  will only check where types are annotated and known
\item
  by default, does not infer types
\item
  much faster than Dialyzer and no PLTs!
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Gradient - an Elixir front-end for Gradualizer}
\protect\hypertarget{gradient---an-elixir-front-end-for-gradualizer}{}
\begin{lstlisting}
# mix.exs
{:gradient, github: "esl/gradient",
  only: [:dev], runtime: false}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example}
\protect\hypertarget{type-example-1}{}
\begin{lstlisting}
defmodule GradientExample.TypeExample do
  @spec add(number(), number()) :: number()
  def add(a, b), do: a + b

  def concat(str1, str2), do: str1 <> str2

  @spec wat(number(), String.t()) :: number()
  def wat(a, b), do: a + b

  def run_add, do: add(1, :two)
  def run_concat, do: concat(:not_a_string, "suffix")
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type example - output}
\protect\hypertarget{type-example---output}{}
\begin{lstlisting}
lib/type_example.ex: The variable on line 8 is expected to have type number()
but it has type binary()
6
7   @spec wat(number(), String.t()) :: number()
8   def wat(a, b), do: a + b
9
10   def run_add, do: add(1, :two)

lib/type_example.ex: The atom on line 10 is expected to have type number()
but it has type :two
8   def wat(a, b), do: a + b
9
10   def run_add, do: add(1, :two)
11   def run_concat, do: concat(:not_a_string, "suffix")
12 end

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Inference example -
\passthrough{\lstinline!mix gradient --infer!}}
\protect\hypertarget{inference-example---mix-gradient---infer}{}
\begin{lstlisting}
defmodule GradientExample.InferExample do
  def wat() do
    1 + "2"
  end
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Infer example - output}
\protect\hypertarget{infer-example---output}{}
\begin{lstlisting}
lib/infer_example.ex: The operator '+' on line 3 is requires numeric arguments,
but has arguments of type 1 and binary()

Total errors: 1
\end{lstlisting}
\end{frame}

\hypertarget{witchcraft-and-algae}{%
\section{Witchcraft and Algae}\label{witchcraft-and-algae}}

\begin{frame}{Typeclasses with Witchcraft}
\protect\hypertarget{typeclasses-with-witchcraft}{}
\begin{itemize}
\tightlist
\item
  \url{https://github.com/witchcrafters/witchcraft}
\item
  provides a typeclass hierarchy similar to Haskell, Scala, or FP-TS
\item
  respective operators such as map, apply, lifts, etc
\item
  tools to create typeclass instances for custom data types
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Witchcraft Typeclass Hierarchy}
\protect\hypertarget{witchcraft-typeclass-hierarchy}{}
\begin{lstlisting}
Semigroupoid  Semigroup  Setoid   Foldable   Functor
     ↓           ↓         ↓         ↓      ↓   ↓
  Category     Monoid     Ord    Traversable  Apply
     ↓                                       ↓     ↓
   Arrow                            Applicative   Chain
                                             ↓    ↓
                                              Monad
\end{lstlisting}
\end{frame}

\begin{frame}{Algebraic Data Types with Algae}
\protect\hypertarget{algebraic-data-types-with-algae}{}
\begin{itemize}
\tightlist
\item
  \url{https://github.com/witchcrafters/algae}
\item
  builds on top of Witchcraft to provide tools to create ADTs
\item
  ADTs: sum and product types

  \begin{itemize}
  \tightlist
  \item
    sum type: Lists, Trees, Maybe / Option, Either
  \item
    product types: records, maps
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Contrived example - TaskEither ADT}
\protect\hypertarget{contrived-example---taskeither-adt}{}
\begin{lstlisting}
defmodule TaskEither do
  import Algae

  defsum do
    defdata(Left :: any())
    defdata(Right :: any())
  end
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Contrived example - TaskEither typeclasses}
\protect\hypertarget{contrived-example---taskeither-typeclasses}{}
\begin{lstlisting}

definst Witchcraft.Functor, for: TaskEither.Left do
  def map(left, _), do: left
end

definst Witchcraft.Functor, for: TaskEither.Right do
  def map(%Right{right: data}, fun),
   do: data |> fun.() |> Right.new()
end

# Apply, Applicative, Chain, Monad ...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Contrived example - TaskEither execution}
\protect\hypertarget{contrived-example---taskeither-execution}{}
\begin{lstlisting}
# >>>/2 is the bind function from Haskell's Monad typclass
> g = fn _t -> TaskEither.Left.new(fn -> :error end) end
#Function<42.3316493/1 in :erl_eval.expr/6>
> f = fn t -> TaskEither.Right.new(fn -> t.() end) end
#Function<42.3316493/1 in :erl_eval.expr/6>
> result = a >>> f >>> g
%TaskEither.Left{left: #Function<43.3316493/0 in :erl_eval.expr/6>}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Thoughts on witchcraftery}
\protect\hypertarget{thoughts-on-witchcraftery}{}
\begin{itemize}
\tightlist
\item
  not very active
\item
  straying from idomatic Elixir (e.g
  \passthrough{\lstinline!\{:ok, data()\} | \{:error, String.t()\}!})
\item
  need to study typeclases, perhaps more of an intellectual curiosity
\end{itemize}
\end{frame}

\begin{frame}{Sneak-peak at the new Elixir Type System}
\protect\hypertarget{sneak-peak-at-the-new-elixir-type-system}{}
\begin{itemize}
\tightlist
\item
  PhD project to introduce a native type system

  \begin{itemize}
  \tightlist
  \item
    Guillaume Duboc under the subervision of Giuseppe Castagna and José
    Valim
  \item
    Paris Cité University and French National Centre for Scientific
    Research
  \end{itemize}
\item
  Semantic Subtyping aka Set-Theoretic types
\item
  research is currently underway

  \begin{itemize}
  \tightlist
  \item
    draft research paper
  \item
    Elixir Conf EU talk
  \item
    demo playground on fly.io
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Features}
\protect\hypertarget{features}{}
\begin{itemize}
\tightlist
\item
  new syntax for type annotations with some reference to the
  \passthrough{\lstinline!@spec!} syntax
\item
  type variables
\item
  understands maps, protocols, guards, and pattern matching
\item
  gradual typing with a \passthrough{\lstinline!dynamic()!} type and
  \passthrough{\lstinline!strong arrows!}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Syntax of a Set-Theoretic type annotation}
\protect\hypertarget{syntax-of-a-set-theoretic-type-annotation}{}
\begin{lstlisting}
negate :: (integer() -> integer())
  and (boolean() -> boolean())
def negate(x) do ...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Type variables}
\protect\hypertarget{type-variables}{}
\begin{lstlisting}
map :: ([a], (a -> b) -> [b] when a: term(), b: term())
def map([h | t], fun), do: [fun.(h) | map(t, fun)]
def map([], _fun), do: []

reduce :: ([a], b, (a, b -> b) -> b
  when a: term(), b: term())
def reduce([h | t], acc, fun),
  do: reduce(t, fun.(h, acc), fun)
def reduce([], acc, _fun), do: acc
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Protocols}
\protect\hypertarget{protocols}{}
\begin{lstlisting}
Enumerable.t(a) and Collectible.t(a) # will be a thing
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Gradual typing and
\passthrough{\lstinline!dynamic()!}}
\protect\hypertarget{gradual-typing-and-dynamic}{}
\begin{itemize}
\tightlist
\item
  sometimes typechecker introduces \passthrough{\lstinline!dynamic()!}
  into the typing
\item
  there will be guarantees of soundness of the typing or a guarantee of
  a runtime type error using guards (e.g.
  \passthrough{\lstinline!is\_integer()!})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Thoughts}
\protect\hypertarget{thoughts}{}
\begin{itemize}
\tightlist
\item
  early days, but very exciting times
\item
  set operators \passthrough{\lstinline!and!} and
  \passthrough{\lstinline!or!} take some getting used to
\item
  the dynamic-typing aspect is a bit unclear (to me)
\item
  will be interesting to see what happens to dialyzer and gradient
\end{itemize}
\end{frame}

\begin{frame}{Resources}
\protect\hypertarget{resources}{}
\begin{itemize}
\tightlist
\item
  \url{https://www.irif.fr/users/gduboc/index}
\item
  \url{https://www.irif.fr/_media/users/gduboc/elixir-types.pdf}
\item
  \url{https://www.youtube.com/watch?v=gJJH7a2J9O8}
\item
  \url{https://typex.fly.dev/}
\end{itemize}
\end{frame}

\begin{frame}{Typex demo}
\protect\hypertarget{typex-demo}{}
\end{frame}

\end{document}
